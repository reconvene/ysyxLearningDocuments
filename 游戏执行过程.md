# 游戏执行过程

首先我们需要明白的是nemu和AM是如何进行交互的?

以*mmio*为例，在打开*CONFIG_DEVICE*后nemu在初始化时会输出如下提示:

```c
[src/device/io/mmio.c:50 add_mmio_map] Add mmio map 'serial' at [0xa00003f8, 0xa00003ff]
[src/device/io/mmio.c:50 add_mmio_map] Add mmio map 'rtc' at [0xa0000048, 0xa000004f]
[src/device/io/mmio.c:50 add_mmio_map] Add mmio map 'vgactl' at [0xa0000100, 0xa0000107]
[src/device/io/mmio.c:50 add_mmio_map] Add mmio map 'vmem' at [0xa1000000, 0xa10752ff]
[src/device/io/mmio.c:50 add_mmio_map] Add mmio map 'keyboard' at [0xa0000060, 0xa0000063]
[src/device/io/mmio.c:50 add_mmio_map] Add mmio map 'audio' at [0xa0000200, 0xa0000217]
[src/device/io/mmio.c:50 add_mmio_map] Add mmio map 'audio-sbuf' at [0xa1200000, 0xa120ffff]
```

可以看到的是nemu会在初始化阶段划分这些"内存空间"来作为寄存器映射，但正如前面双引号所示这些内存空间并不是真正的内存空间，也就是说对应的寄存器信息并不存储在这些实际的内存地址上，现在让我们以serial设备为例来看看它是如何进行初始化的(在本文中为了方便大家理解，处于不同文件位置的相关函数我会放在一块进行说明)

```c
typedef struct {
  const char *name;
  // we treat ioaddr_t as paddr_t here
  paddr_t low;
  paddr_t high;
  void *space;
  io_callback_t callback;
} IOMap;

void init_map() {
  io_space = malloc(IO_SPACE_MAX);
  assert(io_space);
  p_space = io_space;
  IFDEF(CONFIG_DTRACE,deviceLogRingBuffer=createLogRingBuffer(LOG_BUFFER_SIZE));
}

uint8_t* new_space(int size) {
  uint8_t *p = p_space;
  // page aligned;
  size = (size + (PAGE_SIZE - 1)) & ~PAGE_MASK;
  p_space += size;
  assert(p_space - io_space < IO_SPACE_MAX);
  return p;
}

static void report_mmio_overlap(const char *name1, paddr_t l1, paddr_t r1,
    const char *name2, paddr_t l2, paddr_t r2) {
  panic("MMIO region %s@[" FMT_PADDR ", " FMT_PADDR "] is overlapped "
               "with %s@[" FMT_PADDR ", " FMT_PADDR "]", name1, l1, r1, name2, l2, r2);
}

/* device interface */
void add_mmio_map(const char *name, paddr_t addr, void *space, uint32_t len, io_callback_t callback) {
  assert(nr_map < NR_MAP);
  paddr_t left = addr, right = addr + len - 1;
  if (in_pmem(left) || in_pmem(right)) {
    report_mmio_overlap(name, left, right, "pmem", PMEM_LEFT, PMEM_RIGHT);
  }
  for (int i = 0; i < nr_map; i++) {
    if (left <= maps[i].high && right >= maps[i].low) {
      report_mmio_overlap(name, left, right, maps[i].name, maps[i].low, maps[i].high);
    }
  }

  maps[nr_map] = (IOMap){ .name = name, .low = addr, .high = addr + len - 1,
    .space = space, .callback = callback };
  Log("Add mmio map '%s' at [" FMT_PADDR ", " FMT_PADDR "]",
      maps[nr_map].name, maps[nr_map].low, maps[nr_map].high);

  nr_map ++;
}

void init_timer() {
  rtc_port_base = (uint32_t *)new_space(8);
#ifdef CONFIG_HAS_PORT_IO
  add_pio_map ("rtc", CONFIG_RTC_PORT, rtc_port_base, 8, rtc_io_handler);
#else
  add_mmio_map("rtc", CONFIG_RTC_MMIO, rtc_port_base, 8, rtc_io_handler);
#endif
  IFNDEF(CONFIG_TARGET_AM, add_alarm_handle(timer_intr));
}

```

一个IO设备的映射用一个IOMap结构体来表示，name代表IO设备的名称、low代表IO设备的低位内存地址、high代表IO设备的高位内存地址、space代表IO设备的内存空间、callback代表这个设备对应的回调函数。
可以看到的是在*init_serial*函数内首先调用了*new_space*这个函数，它的作用正如它的代码所示在*init_map*中分配的io_space内存空间中划分一块4k对齐的页给serial设备，然后再对设备进行映射。*add_mmio_map*函数就比较简单了，它的作用是检查分配的设备内存地址是否跟其它设备或nemu的内存产生冲突，有个没有则根据填入的参数把设备加入到映射表中并输出相关信息，我们看到的初始化中的输出就是这么来的。

那为什么我说初始化时声明的内存空间不是真正的设备所在的内存空间呢?这时候我们需要注意到的是memory/paddr.c文件中*paddr_write*和*paddr_read*函数会调用对应的mmio函数，即*mmio_write*和*mmio_read*，并将这俩个函数层层解刨：
```c
static inline int find_mapid_by_addr(IOMap *maps, int size, paddr_t addr) {
  int i;
  for (i = 0; i < size; i ++) {
    if (map_inside(maps + i, addr)) {
      difftest_skip_ref();
      return i;
    }
  }
  return -1;
}

static IOMap* fetch_mmio_map(paddr_t addr) {
  int mapid = find_mapid_by_addr(maps, nr_map, addr);
  return (mapid == -1 ? NULL : &maps[mapid]);
}

word_t map_read(paddr_t addr, int len, IOMap *map) {
  assert(len >= 1 && len <= 8);
  check_bound(map, addr);
  paddr_t offset = addr - map->low;
  invoke_callback(map->callback, offset, len, false); // prepare data to read
  word_t ret = host_read(map->space + offset, len);
  return ret;
}

void map_write(paddr_t addr, int len, word_t data, IOMap *map) {
  assert(len >= 1 && len <= 8);
  check_bound(map, addr);
  paddr_t offset = addr - map->low;
  host_write(map->space + offset, len, data);
  invoke_callback(map->callback, offset, len, true);
}

/* bus interface */
word_t mmio_read(paddr_t addr, int len) {
  return map_read(addr, len, fetch_mmio_map(addr));
}

void mmio_write(paddr_t addr, int len, word_t data) {
  map_write(addr, len, data, fetch_mmio_map(addr));
}

```

这时候我们直接阅读源代码可以发现在对设备对应的内存地址进行读写操作时实际上是对设备在初始化时分配的页进行读写，也就是说我们实际上是在访问space相对于设备内存基址的偏移量而非内存地址本身，这也就是为什么上文要给内存地址四个字加双引号的原因。

在这个地方我们继续往下看会发现读函数会在读之前调用设备回调函数，而写函数会在写之后调用设备回调函数。这是因为AM与nemu在交互时假如AM要读取某个设备的内存肯定希望获取的是此设备最新的数据而非旧数据，而AM想到写入某个设备的内存时也肯定希望设备能根据写入的数据及时响应而非在下次写入前才响应。在调用完回调函数后，回调函数再根据偏移量、读写数据长度、操作类型来执行对应的操作，以*rtc_io_handler*函数为例：

```c
static void rtc_io_handler(uint32_t offset, int len, bool is_write) {
  assert(offset == 0 || offset == 4);
  if (!is_write && offset == 0) {
    uint64_t us = get_time();
    rtc_port_base[0] = (uint32_t)us;
    rtc_port_base[1] = us >> 32;
  }
}
```

因为AM不可能也不应该往rtc函数内写入数据，并且rtc函数rtc_port_base有意义的值只存在前64位、一次只能读取32位，因此在处理函数的开头断言rtc的偏移量为0或4即前32位的区间和后32位的区间，同时只处理读取的情况。那为什么if里还要多一个offset==0呢？实际上这是为了照顾32位设备的读取，这样即使是读取前32位也能即使更新时钟数据，并且在读取64位的时钟数据时只要遵守先读取低32位后读取高32位就不会导致高低位时钟数据错乱的现象，也能顺带节省IO开销。

因此，我们通过这些代码可以看出AM与nemu的核心操作就是内存读写，这正对应了mmio的行为。

此时，我们再回过头来看typing-game游戏就可以理清一个游戏是怎么进行的了。在typing_game中一个游戏被分为了俩部分：逻辑帧和画面帧，正如它们的名字一样逻辑帧是描述一秒内更新多少次游戏逻辑的，用来控制游戏内各个物体的行为，渲染帧则是描述一秒内更新多少次游戏画面的，用来提供交互体验，让我们先来看看一帧逻辑帧内具体发生了什么：

```c
#define FPS            30
#define CPS             5
#define CHAR_W          8
#define CHAR_H         16
#define NCHAR         128
#define COL_WHITE    0xeeeeee
#define COL_RED      0xff0033
#define COL_GREEN    0x00cc33
#define COL_PURPLE   0x2a0a29

enum { WHITE = 0, RED, GREEN, PURPLE };
struct character {
  char ch;
  int x, y, v, t;
} chars[NCHAR];

int screen_w, screen_h, hit, miss, wrong;
uint32_t texture[3][26][CHAR_W * CHAR_H], blank[CHAR_W * CHAR_H];

int min(int a, int b) {
  return (a < b) ? a : b;
}

int randint(int l, int r) {
  return l + (rand() & 0x7fffffff) % (r - l + 1);
}

void new_char() {
  for (int i = 0; i < LENGTH(chars); i++) {
    struct character *c = &chars[i];
    if (!c->ch) {
      c->ch = 'A' + randint(0, 25);
      c->x = randint(0, screen_w - CHAR_W);
      c->y = 0;
      c->v = (screen_h - CHAR_H + 1) / randint(FPS * 3 / 2, FPS * 2);
      c->t = 0;
      return;
    }
  }
}

void game_logic_update(int frame) {
  if (frame % (FPS / CPS) == 0) new_char();
  for (int i = 0; i < LENGTH(chars); i++) {
    struct character *c = &chars[i];
    if (c->ch) {
      if (c->t > 0) {
        if (--c->t == 0) {
          c->ch = '\0';
        }
      } else {
        c->y += c->v;
        if (c->y < 0) {
          c->ch = '\0';
        }
        if (c->y + CHAR_H >= screen_h) {
          miss++;
          c->v = 0;
          c->y = screen_h - CHAR_H;
          c->t = FPS;
        }
      }
    }
  }
}
```

首先我们需要明确的是一个字符由x、y、v、t四个属性组成，x和y很好理解即为字符的左上角坐标(这是因为AM渲染代码是从左上角开始按行写入导致的)，v为速度，而t我们看后面代码来理解。现在让我们直接来看*game_logic_update*函数，这个函数是打字游戏中主要的逻辑帧更新函数，它首先会根据FPS/CPS，也就是每秒要刷新的字符数来判断当前逻辑帧是否需要生成新的字符，然后会遍历字符表查找ch不为0的字符，因为如果一个字符在*new_char*函数初始化，ch则会被填入对应值。

在这里我们先看else的部分，可以看到的是c->y+=c-v，即把字符按照随机生成的速度上下移动v个像素。更新完这个字符的位置后，再判断y是否<0，即被击中且超出屏幕外了(游戏中字符被击中则会往上飞)则重置字符，如果触底了(没被击中)则更新miss并且速度归0且设置t。这时候我们再回过头看t成员就能明白它所代表的含义是字符触底后还能存在的帧数，设置为FPS则为处理后存在一秒(如果当前帧数=FPS)后重置。

除了主逻辑更新之外，还有个*check_hit*函数需要看一下：

```c
char lut[256] = {
  [AM_KEY_A] = 'A', [AM_KEY_B] = 'B', [AM_KEY_C] = 'C', [AM_KEY_D] = 'D',
  [AM_KEY_E] = 'E', [AM_KEY_F] = 'F', [AM_KEY_G] = 'G', [AM_KEY_H] = 'H',
  [AM_KEY_I] = 'I', [AM_KEY_J] = 'J', [AM_KEY_K] = 'K', [AM_KEY_L] = 'L',
  [AM_KEY_M] = 'M', [AM_KEY_N] = 'N', [AM_KEY_O] = 'O', [AM_KEY_P] = 'P',
  [AM_KEY_Q] = 'Q', [AM_KEY_R] = 'R', [AM_KEY_S] = 'S', [AM_KEY_T] = 'T',
  [AM_KEY_U] = 'U', [AM_KEY_V] = 'V', [AM_KEY_W] = 'W', [AM_KEY_X] = 'X',
  [AM_KEY_Y] = 'Y', [AM_KEY_Z] = 'Z',
};

void check_hit(char ch) {
  int m = -1;
  for (int i = 0; i < LENGTH(chars); i++) {
    struct character *c = &chars[i];
    if (ch == c->ch && c->v > 0 && (m < 0 || c->y > chars[m].y)) {
      m = i;
    }
  }
  if (m == -1) {
    wrong++;
  } else {
    hit++;
    chars[m].v = -(screen_h - CHAR_H + 1) / (FPS);
  }
}
```

通过阅读源码可发现，此函数主要作用就是判断字符是否被击中并更新状态，如果字符未触底并且往下飞时被击中，则更新hit并将被击中的字符设置为往上飞，如果字符触底(v=0)且被击中则更新wrong，即为击错字符。

看完逻辑帧更新部分后，我们再来看看渲染帧是怎么更新的，首先我们先看画面初始化函数*video_init*：

```c
void video_init() {
  screen_w = io_read(AM_GPU_CONFIG).width;
  screen_h = io_read(AM_GPU_CONFIG).height;

  extern char font[];
  for (int i = 0; i < CHAR_W * CHAR_H; i++)
    blank[i] = COL_PURPLE;

  uint32_t blank_line[screen_w];
  for (int i = 0; i < screen_w; i++)
    blank_line[i] = COL_PURPLE;

  for (int y = 0; y < screen_h; y ++)
    io_write(AM_GPU_FBDRAW, 0, y, blank_line, screen_w, 1, false);

  for (int ch = 0; ch < 26; ch++) {
    char *c = &font[CHAR_H * ch];
    for (int i = 0, y = 0; y < CHAR_H; y++)
      for (int x = 0; x < CHAR_W; x++, i++) {
        int t = (c[y] >> (CHAR_W - x - 1)) & 1;
        texture[WHITE][ch][i] = t ? COL_WHITE : COL_PURPLE;
        texture[GREEN][ch][i] = t ? COL_GREEN : COL_PURPLE;
        texture[RED  ][ch][i] = t ? COL_RED   : COL_PURPLE;
      }
  }
}
```

它首先会通过io_read读取GPU设备的渲染的画面长宽属性，在nemu一般为指定的屏幕大小，然后再按行绘制紫色背景墙，这里的的绘制操作则是通过io_write往GPU设备的显存里写入像素信息实现的。后面再根据font数据存储的字符绘制区域来依次生成26个字母每一个的白色、绿色、红色版本，而font存储的数据我们以字符'A'为例来展示：

```c
// 展开前
0x00, 0x00, 0x1c, 0x36, 0x63, 0x63, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00

// 展开后
00000000
00000000
00011100
00110110
01100011
01100011
01100011
01111111
01100011
01100011
01100011
01100011
00000000
00000000
00000000
00000000
```

可以看出这些16进制数据所代表的就是对应字符每一行要渲染的区域，因为规定了字符的高度有16行，所以这样的数据有16个，*video_init*会把他们按行写入对应的颜色、对应的字符所代表的对应的数组中。这时候我们再来看*render*函数：

```c
void render() {
  static int x[NCHAR], y[NCHAR], n = 0;

  for (int i = 0; i < n; i++) {
    io_write(AM_GPU_FBDRAW, x[i], y[i], blank, CHAR_W, CHAR_H, false);
  }

  n = 0;
  for (int i = 0; i < LENGTH(chars); i++) {
    struct character *c = &chars[i];
    if (c->ch) {
      x[n] = c->x; y[n] = c->y; n++;
      int col = (c->v > 0) ? WHITE : (c->v < 0 ? GREEN : RED);
      io_write(AM_GPU_FBDRAW, c->x, c->y, texture[col][c->ch - 'A'], CHAR_W, CHAR_H, false);
    }
  }
  io_write(AM_GPU_FBDRAW, 0, 0, NULL, 0, 0, true);
  for (int i = 0; i < 40; i++) putch('\b');
  printf("Hit: %d; Miss: %d; Wrong: %d", hit, miss, wrong);
}
```

通过阅读源代码可以发现，*render*函数首先会用色块清除字符上一帧所在的位置，然后遍历字符表，如果发现有字符被初始化了则根据它目前的的速度渲染对应的颜色，根据*game_logic_update*函数v>0则为字符未击中往下飞更新白色、v<0则为字符击中往上飞更新绿色、v=0则为触底更新红色，再完成背景绘画和字符更新后则通过*io_write(AM_GPU_FBDRAW, 0, 0, NULL, 0, 0, true);*将当前显存内存着的数据立马更新到屏幕上，至此则完成完整一帧的渲染。

接下来我们来看函数的主函数：

```c
int main() {
  ioe_init();
  video_init();

  panic_on(!io_read(AM_TIMER_CONFIG).present, "requires timer");
  panic_on(!io_read(AM_INPUT_CONFIG).present, "requires keyboard");

  printf("Type 'ESC' to exit\n");

  int current = 0, rendered = 0;
  uint64_t t0 = io_read(AM_TIMER_UPTIME).us;
  while (1) {
    int frames = (io_read(AM_TIMER_UPTIME).us - t0) / (1000000 / FPS);

    for (; current < frames; current++) {
      game_logic_update(current);
    }

    while (1) {
      AM_INPUT_KEYBRD_T ev = io_read(AM_INPUT_KEYBRD);
      if (ev.keycode == AM_KEY_NONE) break;
      if (ev.keydown && ev.keycode == AM_KEY_ESCAPE) halt(0);
      if (ev.keydown && lut[ev.keycode]) {
        check_hit(lut[ev.keycode]);
      }
    };

    if (current > rendered) {
      render();
      rendered = current;
    }
  }
}
```

主函数中前面的都很好理解，我们从while中的for函数开始，这里的for函数是为了保持游戏逻辑帧数按照指定帧数更新，以防止在IO卡顿或导致延迟的情况下正常维护游戏的进行逻辑，举个例子假如我逻辑帧更新后IO卡顿了50ms才渲染画面，则此时在FPS为30的情况下其实已经跳过一帧逻辑帧，那么在下一次循环中会更新2次逻辑帧来保持正常逻辑更新。更新完逻辑帧后，主函数会通过io_read读取是否有人经过SDL窗口往nemu中输入按键，如果输入了则通过*check_hit*函数更新字符击中状态，在更新完字符更新状态后再通过render函数更新逻辑帧最后一帧的渲染画面，这基本上就是以typing_game游戏为例的完整执行步骤。